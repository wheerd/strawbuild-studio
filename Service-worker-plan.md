Perfect! Now I have a good understanding of the project. Let me create a comprehensive plan that reflects the updated vendor-only chunk setup and the new branded loading screen goals:

## Service Worker & Offline Support Implementation Plan

### **Current State Analysis**

- ✅ Already has lazy loading for `FloorPlanEditor` and `ConstructionViewer3D`
- ✅ Vite manual chunking now scoped to vendor bundles (core framework, 3D stack, UI libs)
- ✅ AppSkeleton component exists for React-level loading state
- ✅ PWA manifest already configured (`site.webmanifest`)
- ❌ No service worker implementation
- ❌ No HTML-level loading screen
- ❌ No chunk preloading strategy

---

### **Implementation Plan**

#### **Phase 1: HTML Loading Screen**

Create an inline HTML loading screen that shows immediately on page load, before any JavaScript executes, and renders correctly even if no other CSS has loaded yet.

**Tasks:**

1. **Convert logo to inline SVG**
   - Simplify existing logo to a plain SVG (no external fonts or scripts)
   - Optimize the SVG (remove metadata, inline fills/strokes) so it can be embedded directly in HTML
   - Store the optimized SVG in the repo (`public/assets/inline-logo.svg`) for reuse/documentation
2. **Update `index.html`** with inline CSS loading screen
   - Add inline styles in `<head>` to avoid FOUC (Flash of Unstyled Content)
   - Keep all loading screen styles self-contained so the layout/appearance is accurate without waiting for external stylesheets
   - Inline the optimized SVG, center it with the app name and spinner prominently inside `#root`
   - Mirror Radix theme colors using CSS custom properties declared inline
3. **Update `main.tsx`** to replace HTML loading screen
   - Add logic to remove the inline loading screen when React hydrates
   - Ensure smooth transition to `AppSkeleton` (or React-level fallback)

---

#### **Phase 2: Service Worker Setup**

Implement caching strategy for offline support and improved loading.

**Tasks:** 3. **Install Vite PWA Plugin**

```bash
pnpm add -D vite-plugin-pwa workbox-window
```

4. **Configure `vite.config.ts`** with PWA plugin
   - Use Workbox with `generateSW` strategy
   - Configure precaching for critical assets
   - Set up runtime caching strategies:
     - **Stale-While-Revalidate** for vendor bundles (React/core, UI kit, data libs)
     - **Stale-While-Revalidate** for feature chunks generated by Vite
     - **Cache-First** for static assets (CSS, fonts, icons)
     - **Network-First** for HTML
     - **Precache** the Three.js vendor bundle for offline 3D viewing

5. **Update `site.webmanifest`**
   - Ensure proper PWA configuration for installability

6. **Create service worker registration** in `main.tsx`
   - Register service worker after React loads
   - Handle update notifications
   - Add skip waiting logic for updates

---

#### **Phase 3: Chunk Preloading Strategy**

Proactively load all chunks in the background for full offline capability, coordinating with the vendor-only manual chunks.

**Tasks:** 7. **Create chunk preloader utility** (`src/shared/services/chunkPreloader.ts`)

- Function to detect all chunks from the Vite build manifest
- Distinguish between vendor bundles (manually chunked) and feature chunks (auto-split)
- Prioritized loading queue (critical → nice-to-have)
- Use `requestIdleCallback` for background loading
- Track loading progress

8. **Implement preloading in `App.tsx`**
   - Start preloading after initial render
   - Preload order:
     1. Critical vendor bundle(s) required for core UI rendering
     2. High-priority feature chunks for FloorPlanEditor and state management
     3. Secondary vendor bundle(s) for optional/advanced capabilities (e.g., 3D)
     4. Remaining feature chunks tied to optional routes/modals
   - Use `<link rel="prefetch">` or dynamic imports

9. **Add preload status indicator** (optional)
   - Small indicator showing offline-ready status
   - Add to status bar or settings panel

---

#### **Phase 4: Loading Flow Optimization**

**Tasks:** 10. **Optimize critical CSS loading** - Keep loading-screen CSS inline and self-contained - Defer non-critical CSS (Radix themes, Tailwind utilities) - Consider inlining other above-the-fold rules

11. **Update build configuration**
    - Verify chunk splitting is optimal
    - Enable CSS code splitting per chunk
    - Configure proper cache headers in preview

12. **Add loading states**
    - Ensure smooth transitions: HTML loading screen → AppSkeleton → FloorPlanEditor
    - Add loading progress for chunk preloading
    - Handle offline state detection

---

#### **Phase 5: Testing & Validation**

**Tasks:** 13. **Test offline functionality** - Test full offline workflow - Verify all chunks are cached - Test updates and cache invalidation - Test on slow 3G network

14. **Lighthouse audit**
    - Ensure PWA compliance
    - Check performance scores
    - Validate caching strategies

15. **Update documentation**
    - Document service worker strategy
    - Add offline capability notes to README
    - Document chunk preloading behavior

---

### **File Structure (New Files)**

```
public/
  sw.js                                    (auto-generated by vite-plugin-pwa)
  assets/
    inline-logo.svg                        (new - optimized SVG used in loading screen)

src/
  shared/
    services/
      chunkPreloader.ts                    (new - chunk preloading utility)
      serviceWorkerRegistration.ts         (new - SW registration logic)
```

---

### **Technical Details**

#### **Caching Strategy**

```
Precache (installed with SW):
- index.html
- Main CSS bundle
- Core vendor bundle (React + router)
- Main app chunk (index.js)

Runtime Cache:
- Navigation: Network-First, 30s timeout fallback to cache
- Vendor JS Chunks: Stale-While-Revalidate, 7 days
- Feature JS Chunks: Stale-While-Revalidate, 7 days
- CSS: Stale-While-Revalidate, 7 days
- Images/Icons: Cache-First, 30 days
- Three.js vendor bundle: Cache-First (large file), 7 days
```

#### **Loading Sequence**

```
1. Browser loads index.html (with inline loading-screen CSS)
2. HTML loading screen renders immediately and looks correct even before any external CSS arrives
3. Browser requests main.tsx + CSS in parallel
4. Service worker intercepts (serves from cache if available)
5. React loads, replaces HTML loading screen with AppSkeleton
6. FloorPlanEditor lazy-loads, replaces AppSkeleton
7. Background: Preloader fetches remaining vendor and feature chunks
8. App fully offline-capable once all chunks cached
```

#### **Chunk Priority**

```
Priority 0 (already loaded): core vendor bundle, index
Priority 1 (needed for core UX): FloorPlanEditor feature chunk(s), data/store feature chunk(s), UI vendor bundle
Priority 2 (nice-to-have): 3D vendor bundle and related feature chunk(s)
```

---

### **Benefits**

1. ✅ **Instant branded loading screen** - Users see logo/name immediately
2. ✅ **No CSS FOUC** - Loading screen uses inline styles
3. ✅ **Offline-first** - Full app works without network
4. ✅ **Progressive enhancement** - Chunks load in background
5. ✅ **Cache efficiency** - Smart invalidation on updates
6. ✅ **PWA installable** - Users can install as native app

---

### **Potential Issues & Solutions**

| Issue                                     | Solution                                                      |
| ----------------------------------------- | ------------------------------------------------------------- |
| Large Three.js vendor bundle delays offline-ready | Load with lowest priority, only cache if user opens 3D viewer |
| Service worker updates                    | Implement update notification banner, allow user to refresh   |
| Dev/prod parity                           | Service worker only in production builds                      |
| Build size increase                       | Workbox is tree-shakeable, minimal overhead                   |

---

### **Next Steps**

Would you like me to proceed with implementation? I can either:

1. **Implement all phases** sequentially
2. **Start with Phase 1+2** (loading screen + service worker basics)
3. **Prototype a specific phase** first for your review

Let me know how you'd like to proceed!
